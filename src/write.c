/*
 * @Author: hxy
 * @Date: 2023-10-05 20:53:48
 * @LastEditTime: 2023-11-28 16:05:52
 * @Description: 请填写简介
 */

#include "as.h"
#include "subsegs.h"
#include "obstack.h"
#include "output-file.h"
// 符号是否被冻结
int symbol_table_frozen;

int finalize_syms = 0;

symbolS *abs_section_sym;

/* 解析表达式时保存的.符号的偏移量  */
addressT dot_value;

/* dot_value 基于的片段  */
fragS *dot_frag;

/* Relocs generated by ".reloc" pseudo.  */
struct reloc_list* reloc_list;
#ifndef TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
#define TC_FINALIZE_SYMS_BEFORE_SIZE_SEG 1
#endif

#ifndef TC_LINKRELAX_FIXUP
#define TC_LINKRELAX_FIXUP(SEG) 1
#endif

#ifndef md_register_arithmetic
# define md_register_arithmetic 1
#endif

#ifndef TC_FORCE_RELOCATION_SUB_LOCAL
#ifdef DIFF_EXPR_OK
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
#else
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG)	1
#endif
#endif

#ifndef TC_FORCE_RELOCATION_SUB_ABS
#define TC_FORCE_RELOCATION_SUB_ABS(FIX, SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
#endif

#ifndef	MD_PCREL_FROM_SECTION
#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from (FIX)
#endif

#ifndef TC_VALIDATE_FIX_SUB
#define TC_VALIDATE_FIX_SUB(FIX, SEG) 0
#endif

#ifndef TC_FAKE_LABEL
#define TC_FAKE_LABEL(NAME) (strcmp ((NAME), FAKE_LABEL_NAME) == 0)
#endif

#ifndef TC_FX_SIZE_SLACK
#define TC_FX_SIZE_SLACK(FIX) 0
#endif

#define GENERIC_FORCE_RELOCATION_SUB_SAME(FIX, SEG)	\
  (!SEG_NORMAL (SEG))
#define GENERIC_FORCE_RELOCATION_LOCAL(FIX)	\
  (!(FIX)->fx_pcrel				\
   || TC_FORCE_RELOCATION (FIX))
struct relax_seg_info {
    int pass;
    int changed;
};

extern valueT md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size);
/**
 * @Description: 转换成字节流
 */
void
number_to_chars_littleendian (char *buf, valueT val, int n) {
    if (n <= 0)
        abort ();
    while (n--) {
        *buf++ = val & 0xff;
        val >>= 8;
    }
}

void
number_to_chars_bigendian (char *buf, valueT val, int n)
{
  if (n <= 0)
    abort ();
  while (n--)
    {
      buf[n] = val & 0xff;
      val >>= 8;
    }
}


void
record_alignment (/* Segment to which alignment pertains.  */
		  segT seg,
		  /* Alignment, as a power of 2 (e.g., 1 => 2-byte
		     boundary, 2 => 4-byte boundary, etc.)  */
		  unsigned int align) {
    if (seg == absolute_section)
        return;

    if (align > bfd_section_alignment (seg))
        bfd_set_section_alignment (seg, align);
}

static bool frags_chained = false;

static unsigned int n_fixups;

#define RELOC_ENUM enum bfd_reloc_code_real

void
as_bad_subtract (fixS *fixp) {
    as_bad_where (fixp->fx_file, fixp->fx_line,
            _("can't resolve %s - %s"),
            fixp->fx_addsy ? S_GET_NAME (fixp->fx_addsy) : "0",
            S_GET_NAME (fixp->fx_subsy));
}

/**
 * @Description:  Create a fixS in obstack 'notes'. 
 */
static fixS *
fix_new_internal (fragS *frag,		/* Which frag?  */
		  unsigned long where,	/* Where in that frag?  */
		  unsigned long size,	/* 1, 2, or 4 usually.  */
		  symbolS *add_symbol,	/* X_add_symbol.  */
		  symbolS *sub_symbol,	/* X_op_symbol.  */
		  offsetT offset,	/* X_add_number.  */
		  int pcrel,		/* TRUE if PC-relative relocation.  */
		  RELOC_ENUM r_type	/* Relocation type.  */,
		  int at_beginning) {	/* Add to the start of the list?  */
    fixS *fixP;

    n_fixups++;

    fixP = (fixS *) obstack_alloc (&notes, sizeof (fixS));

    fixP->fx_frag = frag;
    fixP->fx_where = where;
    fixP->fx_size = size;
    /* We've made fx_size a narrow field; check that it's wide enough.  */
    if (fixP->fx_size != size) {
        as_bad (_("field fx_size too small to hold %lu"), size);
        abort ();
    }
    fixP->fx_addsy = add_symbol;
    fixP->fx_subsy = sub_symbol;
    fixP->fx_offset = offset;
    fixP->fx_dot_value = dot_value;
    fixP->fx_dot_frag = dot_frag;
    fixP->fx_pcrel = pcrel;
    fixP->fx_r_type = r_type;
    fixP->fx_pcrel_adjust = 0;
    fixP->fx_addnumber = 0;
    fixP->fx_tcbit = 0;
    fixP->fx_tcbit2 = 0;
    fixP->fx_done = 0;
    fixP->fx_no_overflow = 0;
    fixP->fx_signed = 0;

    #ifdef USING_CGEN
    fixP->fx_cgen.insn = NULL;
    fixP->fx_cgen.opinfo = 0;
    #endif

    #ifdef TC_FIX_TYPE
    TC_INIT_FIX_DATA (fixP);
    #endif

    fixP->fx_file = as_where (&fixP->fx_line);

    {
        fixS **seg_fix_rootP = (frags_chained
                    ? &seg_info (now_seg)->fix_root
                    : &frchain_now->fix_root);
        fixS **seg_fix_tailP = (frags_chained
                    ? &seg_info (now_seg)->fix_tail
                    : &frchain_now->fix_tail);

        if (at_beginning) {
            fixP->fx_next = *seg_fix_rootP;
            *seg_fix_rootP = fixP;
            if (fixP->fx_next == NULL)
                *seg_fix_tailP = fixP;
        } else {
            fixP->fx_next = NULL;
            if (*seg_fix_tailP)
                (*seg_fix_tailP)->fx_next = fixP;
            else
                *seg_fix_rootP = fixP;
            *seg_fix_tailP = fixP;
        }
    }

    return fixP;
}

fixS *
fix_new_exp (fragS *frag,		/* Which frag?  */
	     unsigned long where,	/* Where in that frag?  */
	     unsigned long size,	/* 1, 2, or 4 usually.  */
	     expressionS *exp,		/* Expression.  */
	     int pcrel,			/* TRUE if PC-relative relocation.  */
	     RELOC_ENUM r_type		/* Relocation type.  */)
{
    symbolS *add = NULL;
    symbolS *sub = NULL;
    offsetT off = 0;

    switch (exp->X_op) {
        case O_absent:
            break;

        case O_register:
            as_bad (_("register value used as expression"));
            break;

        case O_add:
        /* This comes up when _GLOBAL_OFFSET_TABLE_+(.-L0) is read, if
        the difference expression cannot immediately be reduced.  */
        {
            symbolS *stmp = make_expr_symbol (exp);

            exp->X_op = O_symbol;
            exp->X_op_symbol = 0;
            exp->X_add_symbol = stmp;
            exp->X_add_number = 0;

            return fix_new_exp (frag, where, size, exp, pcrel, r_type);
        }

        case O_symbol_rva:
            add = exp->X_add_symbol;
            off = exp->X_add_number;
            r_type = BFD_RELOC_RVA;
        break;

        case O_uminus:
            sub = exp->X_add_symbol;
            off = exp->X_add_number;
        break;

        case O_subtract:
        sub = exp->X_op_symbol;
        /* Fall through.  */
        case O_symbol:
            add = exp->X_add_symbol;
        /* Fall through.  */
        case O_constant:
            off = exp->X_add_number;
            break;

        default:
            add = make_expr_symbol (exp);
            break;
    }

    return fix_new_internal (frag, where, size, add, sub, off, pcrel,
			   r_type, false);
}

fixS *
fix_new (fragS *frag,			/* Which frag?  */
	 unsigned long where,		/* Where in that frag?  */
	 unsigned long size,		/* 1, 2, or 4 usually.  */
	 symbolS *add_symbol,		/* X_add_symbol.  */
	 offsetT offset,		/* X_add_number.  */
	 int pcrel,			/* TRUE if PC-relative relocation.  */
	 RELOC_ENUM r_type		/* Relocation type.  */) {
    return fix_new_internal (frag, where, size, add_symbol,
                (symbolS *) NULL, offset, pcrel, r_type, false);
}

int
get_recorded_alignment (segT seg) {
    if (seg == absolute_section)
        return 0;

    return bfd_section_alignment (seg);
}

/**
 * @Description: 对一个节（section）中的子段
 * （subsegment）进行填充以达到对齐的效果
 */
static void
subsegs_finish_section (asection *s) {
    struct frchain *frchainP;
    segment_info_type *seginfo = seg_info (s);
    if (!seginfo)
        return;
    for (frchainP = seginfo->frchainP;
       frchainP != NULL;
       frchainP = frchainP->frch_next) {
        int alignment;

        subseg_set (s, frchainP->frch_subseg);
        if (had_errors ())
            do_not_pad_sections_to_alignment = 1;
            
        // 判断是否是最后一个子段并对齐
        alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
        if ((bfd_section_flags (now_seg) & SEC_MERGE)
            && now_seg->entsize) {
            unsigned int entsize = now_seg->entsize;
            int entalign = 0;

            while ((entsize & 1) == 0) {
                ++entalign;
                entsize >>= 1;
            }

            if (entalign > alignment)
                alignment = entalign;
        }

        if (subseg_text_p (now_seg))
            frag_align_code (alignment, 0);
        else
            frag_align (alignment, 0, 0);
        frag_wane (frag_now);
        frag_now->fr_fix = 0;
        know (frag_now->fr_next == NULL);
    }
}

static void
subsegs_finish (void) {
    asection *s;

    for (s = stdoutput->sections; s; s = s->next)
        subsegs_finish_section (s);
}

static void
merge_data_into_text (void) {
    seg_info (text_section)->frchainP->frch_last->fr_next =
        seg_info (data_section)->frchainP->frch_root;
    seg_info (text_section)->frchainP->frch_last =
        seg_info (data_section)->frchainP->frch_last;
    seg_info (data_section)->frchainP = 0;
}

static void
renumber_sections (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *countparg) {
    int *countp = (int *) countparg;

    sec->index = *countp;
    ++*countp;
}

static fragS *
chain_frchains_together_1 (segT section, struct frchain *frchp) {
    fragS dummy, *prev_frag = &dummy;
    fixS fix_dummy, *prev_fix = &fix_dummy;

    do {
        prev_frag->fr_next = frchp->frch_root;
        prev_frag = frchp->frch_last;
        gas_assert (prev_frag->fr_type != 0);
        if (frchp->fix_root != (fixS *) NULL) {
            if (seg_info (section)->fix_root == (fixS *) NULL)
                seg_info (section)->fix_root = frchp->fix_root;
            prev_fix->fx_next = frchp->fix_root;
            seg_info (section)->fix_tail = frchp->fix_tail;
            prev_fix = frchp->fix_tail;
        }
        frchp = frchp->frch_next;
    } while (frchp);
    gas_assert (prev_frag != &dummy
            && prev_frag->fr_type != 0);
    prev_frag->fr_next = 0;
    return prev_frag;
}

static void
chain_frchains_together (bfd *abfd ATTRIBUTE_UNUSED,
			 segT section,
			 void *xxx ATTRIBUTE_UNUSED) {
    segment_info_type *info;

    /* BFD may have introduced its own sections without using
        subseg_new, so it is possible that seg_info is NULL.  */
    info = seg_info (section);
    if (info != (segment_info_type *) NULL)
        info->frchainP->frch_last
        = chain_frchains_together_1 (section, info->frchainP);

    /* Now that we've chained the frags together, we must add new fixups
        to the segment, not to the frag chain.  */
    frags_chained = true;
}

/* Relax_align. Advance location counter to next address that has 'alignment'
   lowest order bits all 0s, return size of adjustment made.  */
static relax_addressT
relax_align (relax_addressT address,	/* Address now.  */
	     int alignment	/* Alignment (binary).  */) {
    relax_addressT mask;
    relax_addressT new_address;

    mask = ~((relax_addressT) ~0 << alignment);
    new_address = (address + mask) & (~mask);
#ifdef LINKER_RELAXING_SHRINKS_ONLY
    if (linkrelax)
        /* We must provide lots of padding, so the linker can discard it
        when needed.  The linker will not add extra space, ever.  */
        new_address += (1 << alignment);
#endif
    return (new_address - address);
}

int
relax_segment (struct frag *segment_frag_root, segT segment, int pass) {
    unsigned long frag_count;
    struct frag *fragP;
    relax_addressT address;
    int region;
    int ret;

    /* In case md_estimate_size_before_relax() wants to make fixSs.  */
    subseg_change (segment, 0);
    /* For each frag in segment: count and store  (a 1st guess of)
     fr_address.  */
    address = 0;
    region = 0;
     for (frag_count = 0, fragP = segment_frag_root;
       fragP;
       fragP = fragP->fr_next, frag_count ++) {
        fragP->region = region;
        fragP->relax_marker = 0;
        fragP->fr_address = address;
        address += fragP->fr_fix;
        switch (fragP->fr_type) {
            case rs_fill:
                address += fragP->fr_offset * fragP->fr_var;
                break;

            case rs_align:
            case rs_align_code:
            case rs_align_test:
            {
                addressT offset = relax_align (address, (int) fragP->fr_offset);

                if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
                    offset = 0;
                if (offset % fragP->fr_var != 0) {
                    as_bad_where (fragP->fr_file, fragP->fr_line,
                            ngettext ("alignment padding (%lu byte) "
                                "not a multiple of %ld",
                                "alignment padding (%lu bytes) "
                                "not a multiple of %ld",
                                (unsigned long) offset),
                            (unsigned long) offset, (long) fragP->fr_var);
                    offset -= (offset % fragP->fr_var);
                }
                address += offset;
                region += 1;
            }
            break;
        }
    }


}

static void
relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx) {
    segment_info_type *seginfo = seg_info (sec);
    struct relax_seg_info *info = (struct relax_seg_info *) xxx;

    if (seginfo && seginfo->frchainP
        && relax_segment (seginfo->frchainP->frch_root, sec, info->pass))
        info->changed = 1;
}

static void
cvt_frag_to_fill (segT sec ATTRIBUTE_UNUSED, fragS *fragP)
{
    switch (fragP->fr_type) {
        case rs_space_nop:
        goto skip_align;
        case rs_align:
        case rs_align_code:
        case rs_align_test:
        case rs_org:
        case rs_space:
#ifdef HANDLE_ALIGN
    HANDLE_ALIGN (fragP);
#endif
    skip_align:
        know (fragP->fr_next != NULL);
        fragP->fr_offset = (fragP->fr_next->fr_address
			  - fragP->fr_address
			  - fragP->fr_fix) / fragP->fr_var;
        if (fragP->fr_offset < 0) {
            as_bad_where (fragP->fr_file, fragP->fr_line,
                    _("attempt to .org/.space/.nops backwards? (%ld)"),
                    (long) fragP->fr_offset);
            fragP->fr_offset = 0;
        }
        if (fragP->fr_type == rs_space_nop)
            fragP->fr_type = rs_fill_nop;
        else
            fragP->fr_type = rs_fill;
        break;

        case rs_fill:
        case rs_fill_nop:
            break;

        default:
            BAD_CASE (fragP->fr_type);
            break;
    }
}

static void
size_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx ATTRIBUTE_UNUSED) {
    flagword flags;
    fragS *fragp;
    segment_info_type *seginfo;
    int x;
    valueT size, newsize;

    // 改变当前段
    subseg_change (sec, 0);

    seginfo = seg_info (sec);
    if (seginfo && seginfo->frchainP) {
        for (fragp = seginfo->frchainP->frch_root; fragp; fragp = fragp->fr_next)
            cvt_frag_to_fill (sec, fragp);
        for (fragp = seginfo->frchainP->frch_root;
            fragp->fr_next;
            fragp = fragp->fr_next)
        /* Walk to last elt.  */
            ;
        size = fragp->fr_address + fragp->fr_fix;
    }
    else
        size = 0;

    flags = bfd_section_flags (sec);
    if (size == 0 && bfd_section_size (sec) != 0 &&
        (flags & SEC_HAS_CONTENTS) != 0)
            return;

    if (size > 0 && ! seginfo->bss)
        flags |= SEC_HAS_CONTENTS;

    x = bfd_set_section_flags (sec, flags);
    gas_assert (x);

    /* If permitted, allow the backend to pad out the section
        to some alignment boundary.  */
    if (do_not_pad_sections_to_alignment)
        newsize = size;
    else
        newsize = md_section_align (sec, size);
    x = bfd_set_section_size (sec, newsize);
    gas_assert (x);

    /* If the size had to be rounded up, add some padding in the last
     non-empty frag.  */
    gas_assert (newsize >= size);
    if (size != newsize) {
        fragS *last = seginfo->frchainP->frch_last;
        fragp = seginfo->frchainP->frch_root;
        while (fragp->fr_next != last)
            fragp = fragp->fr_next;
        last->fr_address = size;
        if ((newsize - size) % fragp->fr_var == 0)
            fragp->fr_offset += (newsize - size) / fragp->fr_var;
        else
            abort ();
    }

}

static void
create_obj_attrs_section (void) {
   // maybe 创建.ARM.attribute段 没必要？
}

static void
resolve_reloc_expr_symbols (void) {
    bfd_vma addr_mask = 1;
    struct reloc_list *r;

    /* Avoid a shift by the width of type.  */
    addr_mask <<= bfd_arch_bits_per_address (stdoutput) - 1;
    addr_mask <<= 1;
    addr_mask -= 1;
    for (r = reloc_list; r; r = r->next) {
        reloc_howto_type *howto = r->u.a.howto;
        expressionS *symval;
        symbolS *sym;
        bfd_vma offset, addend;
        asection *sec;

        resolve_symbol_value (r->u.a.offset_sym);
        symval = symbol_get_value_expression (r->u.a.offset_sym);

        offset = 0;
        sym = NULL;
        if (symval->X_op == O_constant)
            sym = r->u.a.offset_sym;
        else if (symval->X_op == O_symbol) {
            sym = symval->X_add_symbol;
            offset = symval->X_add_number;
            symval = symbol_get_value_expression (symval->X_add_symbol);
        }
         if (sym == NULL
        || symval->X_op != O_constant
        || (sec = S_GET_SEGMENT (sym)) == NULL
        || !SEG_NORMAL (sec)) {
            as_bad_where (r->file, r->line, _("invalid offset expression"));
            sec = NULL;
        }
        else
            offset += S_GET_VALUE (sym);

        sym = NULL;
        addend = r->u.a.addend;
        if (r->u.a.sym != NULL) {
            resolve_symbol_value (r->u.a.sym);
            symval = symbol_get_value_expression (r->u.a.sym);
            if (symval->X_op == O_constant)
                sym = r->u.a.sym;
            else if (symval->X_op == O_symbol) {
                sym = symval->X_add_symbol;
                addend += symval->X_add_number;
                symval = symbol_get_value_expression (symval->X_add_symbol);
            }
            if (symval->X_op != O_constant) {
                as_bad_where (r->file, r->line, _("invalid reloc expression"));
                sec = NULL;
            } else if (sym != NULL && sec != NULL) {
                if (S_IS_LOCAL (sym)
                    && S_IS_DEFINED (sym)
                    && !symbol_section_p (sym)
                    && (sec->use_rela_p
                    || (howto->partial_inplace
                    && (!howto->pc_relative
                        || howto->src_mask == addr_mask)))) {
                    asection *symsec = S_GET_SEGMENT (sym);
                    if (!(((symsec->flags & SEC_MERGE) != 0
                        && addend != 0)
                        || (symsec->flags & SEC_THREAD_LOCAL) != 0)) {
                        addend += S_GET_VALUE (sym);
                        sym = section_symbol (symsec);
                    }
                }
                symbol_mark_used_in_reloc (sym);
            }
        }
        if (sym == NULL) {
            if (abs_section_sym == NULL)
                abs_section_sym = section_symbol (absolute_section);
            sym = abs_section_sym;
        }

        r->u.b.sec = sec;
        r->u.b.s = symbol_get_bfdsym (sym);
        r->u.b.r.sym_ptr_ptr = &r->u.b.s;
        r->u.b.r.address = offset;
        r->u.b.r.addend = addend;
        r->u.b.r.howto = howto;
    }
}

#define dump_section_relocs(ABFD,SEC,STREAM)	((void) 0)

#ifndef EMIT_SECTION_SYMBOLS
#define EMIT_SECTION_SYMBOLS 1
#endif
/* This pass over fixups decides whether symbols can be replaced with
   section symbols.  */

static void
adjust_reloc_syms (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *sec,
		   void *xxx ATTRIBUTE_UNUSED) {
    segment_info_type *seginfo = seg_info (sec);
    fixS *fixp;

    if (seginfo == NULL)
        return;

    dump_section_relocs (abfd, sec, stderr);

    for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
        if (fixp->fx_done)
            /* Ignore it.  */
            ;
        else if (fixp->fx_addsy) {
            symbolS *sym;
            asection *symsec;

            sym = fixp->fx_addsy;

            /* All symbols should have already been resolved at this
            point.  It is possible to see unresolved expression
            symbols, though, since they are not in the regular symbol
            table.  */
            resolve_symbol_value (sym);

            if (fixp->fx_subsy != NULL)
                resolve_symbol_value (fixp->fx_subsy);

            /* If this symbol is equated to an undefined or common symbol,
            convert the fixup to being against that symbol.  */
            while (symbol_equated_reloc_p (sym)
                || S_IS_WEAKREFR (sym)) {
                symbolS *newsym = symbol_get_value_expression (sym)->X_add_symbol;
                if (sym == newsym)
                    break;
                fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
                fixp->fx_addsy = newsym;
                sym = newsym;
            }

            if (symbol_mri_common_p (sym)) {
                fixp->fx_offset += S_GET_VALUE (sym);
                fixp->fx_addsy = symbol_get_value_expression (sym)->X_add_symbol;
                continue;
            }

            /* If the symbol is undefined, common, weak, or global (ELF
            shared libs), we can't replace it with the section symbol.  */
            // 其实就是改变fixp中的fx_addsy,加入是本地sym就将name改成.text即section symbol
            if (S_FORCE_RELOC (fixp->fx_addsy, 1))
                continue;

            /* Since we're reducing to section symbols, don't attempt to reduce
            anything that's already using one.  */
            if (symbol_section_p (sym)) {
                /* Mark the section symbol used in relocation so that it will
                    be included in the symbol table.  */
                symbol_mark_used_in_reloc (sym);
                continue;
            }

            symsec = S_GET_SEGMENT (sym);
            if (symsec == NULL)
                abort ();

            if (bfd_is_abs_section (symsec)
                || symsec == reg_section) {
                /* The fixup_segment routine normally will not use this
                symbol in a relocation.  */
                continue;
            }

            /* Don't try to reduce relocs which refer to non-local symbols
            in .linkonce sections.  It can lead to confusion when a
            debugging section refers to a .linkonce section.  I hope
            this will always be correct.  */
            if (symsec != sec && ! S_IS_LOCAL (sym)) {
                if ((symsec->flags & SEC_LINK_ONCE) != 0
                || (IS_ELF
                    /* The GNU toolchain uses an extension for ELF: a
                    section beginning with the magic string
                    .gnu.linkonce is a linkonce section.  */
                    && startswith (segment_name (symsec), ".gnu.linkonce")))
                continue;
            }

            /* Never adjust a reloc against local symbol in a merge section
            with non-zero addend.  */
            if ((symsec->flags & SEC_MERGE) != 0
                && (fixp->fx_offset != 0 || fixp->fx_subsy != NULL))
                continue;

            /* Never adjust a reloc against TLS local symbol.  */
            if ((symsec->flags & SEC_THREAD_LOCAL) != 0)
                continue;

            /* We refetch the segment when calling section_symbol, rather
            than using symsec, because S_GET_VALUE may wind up changing
            the section when it calls resolve_symbol_value.  */
            fixp->fx_offset += S_GET_VALUE (sym);
            fixp->fx_addsy = section_symbol (S_GET_SEGMENT (sym));
        }

    dump_section_relocs (abfd, sec, stderr);
}

static void
fixup_segment (fixS *fixP, segT this_segment)
{
  valueT add_number;
  fragS *fragP;

  if (fixP != NULL && abs_section_sym == NULL)
    abs_section_sym = section_symbol (absolute_section);

  /* If the linker is doing the relaxing, we must not do any fixups.

     Well, strictly speaking that's not true -- we could do any that
     are PC-relative and don't cross regions that could change size.  */
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment))
    {
      for (; fixP; fixP = fixP->fx_next)
	if (!fixP->fx_done)
	  {
	    if (fixP->fx_addsy == NULL)
	      {
		/* There was no symbol required by this relocation.
		   However, BFD doesn't really handle relocations
		   without symbols well. So fake up a local symbol in
		   the absolute section.  */
		fixP->fx_addsy = abs_section_sym;
	      }
	    symbol_mark_used_in_reloc (fixP->fx_addsy);
	    if (fixP->fx_subsy != NULL)
	      symbol_mark_used_in_reloc (fixP->fx_subsy);
	  }
      return;
    }
int n = 0;
  for (; fixP; fixP = fixP->fx_next)
    {
      segT add_symbol_segment = absolute_section;
#ifdef DEBUG5
      fprintf (stderr, "\nprocessing fixup:\n");
      print_fixup (fixP);
#endif

      fragP = fixP->fx_frag;
      know (fragP);
#ifdef TC_VALIDATE_FIX
      TC_VALIDATE_FIX (fixP, this_segment, skip);
#endif
      add_number = fixP->fx_offset;

      if (fixP->fx_addsy != NULL)
	add_symbol_segment = S_GET_SEGMENT (fixP->fx_addsy);

      if (fixP->fx_subsy != NULL)
	{
	  segT sub_symbol_segment;

	  resolve_symbol_value (fixP->fx_subsy);
	  sub_symbol_segment = S_GET_SEGMENT (fixP->fx_subsy);

	  if (fixP->fx_addsy != NULL
	      && sub_symbol_segment == add_symbol_segment
	      && !S_FORCE_RELOC (fixP->fx_addsy, 0)
	      && !S_FORCE_RELOC (fixP->fx_subsy, 0)
	      && !TC_FORCE_RELOCATION_SUB_SAME (fixP, add_symbol_segment))
	    {
	      add_number += S_GET_VALUE_WHERE (fixP->fx_addsy, fixP->fx_file, fixP->fx_line);
	      add_number -= S_GET_VALUE_WHERE (fixP->fx_subsy, fixP->fx_file, fixP->fx_line);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	      fixP->fx_subsy = NULL;
#ifdef TC_M68K
	      /* See the comment below about 68k weirdness.  */
	      fixP->fx_pcrel = 0;
#endif
	    }
	  else if (sub_symbol_segment == absolute_section
		   && !S_FORCE_RELOC (fixP->fx_subsy, 0)
		   && !TC_FORCE_RELOCATION_SUB_ABS (fixP, add_symbol_segment))
	    {
	      add_number -= S_GET_VALUE_WHERE (fixP->fx_subsy, fixP->fx_file, fixP->fx_line);
	      fixP->fx_offset = add_number;
	      fixP->fx_subsy = NULL;
	    }
	  else if (sub_symbol_segment == this_segment
		   && !S_FORCE_RELOC (fixP->fx_subsy, 0)
		   && !TC_FORCE_RELOCATION_SUB_LOCAL (fixP, add_symbol_segment))
	    {
	      add_number -= S_GET_VALUE_WHERE (fixP->fx_subsy, fixP->fx_file, fixP->fx_line);
	      fixP->fx_offset = (add_number + fixP->fx_dot_value
				 + fixP->fx_dot_frag->fr_address);

	      /* Make it pc-relative.  If the back-end code has not
		 selected a pc-relative reloc, cancel the adjustment
		 we do later on all pc-relative relocs.  */
	      if (0
#ifdef TC_M68K
		  /* Do this for m68k even if it's already described
		     as pc-relative.  On the m68k, an operand of
		     "pc@(foo-.-2)" should address "foo" in a
		     pc-relative mode.  */
		  || 1
#endif
		  || !fixP->fx_pcrel)
		add_number += MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_subsy = NULL;
	      fixP->fx_pcrel = 1;
	    }
	  else if (!TC_VALIDATE_FIX_SUB (fixP, add_symbol_segment))
	    {
	      if (!md_register_arithmetic
		  && (add_symbol_segment == reg_section
		      || sub_symbol_segment == reg_section))
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("register value used as expression"));
	      else
		as_bad_subtract (fixP);
	    }
	  else if (sub_symbol_segment != undefined_section
		   && ! bfd_is_com_section (sub_symbol_segment)
		   && MD_APPLY_SYM_VALUE (fixP))
	    add_number -= S_GET_VALUE_WHERE (fixP->fx_subsy, fixP->fx_file, fixP->fx_line);
	}

      if (fixP->fx_addsy)
	{
	  if (add_symbol_segment == this_segment
	      && !S_FORCE_RELOC (fixP->fx_addsy, 0)
	      && !TC_FORCE_RELOCATION_LOCAL (fixP))
	    {
	      /* This fixup was made when the symbol's segment was
		 SEG_UNKNOWN, but it is now in the local segment.
		 So we know how to do the address without relocation.  */
	      add_number += S_GET_VALUE_WHERE (fixP->fx_addsy, fixP->fx_file, fixP->fx_line);
	      fixP->fx_offset = add_number;
	      if (fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_addsy = NULL;
	      fixP->fx_pcrel = 0;
	    }
	  else if (add_symbol_segment == absolute_section
		   && !S_FORCE_RELOC (fixP->fx_addsy, 0)
		   && !TC_FORCE_RELOCATION_ABS (fixP))
	    {
	      add_number += S_GET_VALUE_WHERE (fixP->fx_addsy, fixP->fx_file, fixP->fx_line);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	    }
	  else if (add_symbol_segment != undefined_section
		   && ! bfd_is_com_section (add_symbol_segment)
		   && MD_APPLY_SYM_VALUE (fixP))
	    add_number += S_GET_VALUE_WHERE (fixP->fx_addsy, fixP->fx_file, fixP->fx_line);
	}

      if (fixP->fx_pcrel)
	{
	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	  if (!fixP->fx_done && fixP->fx_addsy == NULL)
	    {
	      /* There was no symbol required by this relocation.
		 However, BFD doesn't really handle relocations
		 without symbols well. So fake up a local symbol in
		 the absolute section.  */
	      fixP->fx_addsy = abs_section_sym;
	    }
	}
if (n == 20) {
    printf("go to 20\n");
}
      if (!fixP->fx_done)
	md_apply_fix (fixP, &add_number, this_segment);

      if (!fixP->fx_done)
	{
	  if (fixP->fx_addsy == NULL)
	    fixP->fx_addsy = abs_section_sym;
	  symbol_mark_used_in_reloc (fixP->fx_addsy);
	  if (fixP->fx_subsy != NULL)
	    symbol_mark_used_in_reloc (fixP->fx_subsy);
	}

      if (!fixP->fx_no_overflow && fixP->fx_size != 0)
	{
	  if (fixP->fx_size < sizeof (valueT))
	    {
	      valueT mask;

	      mask = 0;
	      mask--;		/* Set all bits to one.  */
	      mask <<= fixP->fx_size * 8 - (fixP->fx_signed ? 1 : 0);
	      if ((add_number & mask) != 0
		  && (fixP->fx_signed
		      ? (add_number & mask) != mask
		      : (-add_number & mask) != 0))
		{
		  char buf[50], buf2[50];
		  bfd_sprintf_vma (stdoutput, buf, fragP->fr_address + fixP->fx_where);
		  if (add_number > 1000)
		    bfd_sprintf_vma (stdoutput, buf2, add_number);
		  else
		    sprintf (buf2, "%ld", (long) add_number);
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				ngettext ("value of %s too large for field "
					  "of %d byte at %s",
					  "value of %s too large for field "
					  "of %d bytes at %s",
					  fixP->fx_size),
				buf2, fixP->fx_size, buf);
		} /* Generic error checking.  */
	    }
#ifdef WARN_SIGNED_OVERFLOW_WORD
	  /* Warn if a .word value is too large when treated as a signed
	     number.  We already know it is not too negative.  This is to
	     catch over-large switches generated by gcc on the 68k.  */
	  if (!flag_signed_overflow_ok
	      && fixP->fx_size == 2
	      && add_number > 0x7fff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("signed .word overflow; switch may be too large; %ld at 0x%lx"),
			  (long) add_number,
			  (long) (fragP->fr_address + fixP->fx_where));
#endif
	}

#ifdef TC_VALIDATE_FIX
    skip:  ATTRIBUTE_UNUSED_LABEL
      ;
#endif
#ifdef DEBUG5
      fprintf (stderr, "result:\n");
      print_fixup (fixP);
#endif
    }				/* For each fixS in this segment.  */
}

static void
fix_segment (bfd *abfd ATTRIBUTE_UNUSED,
	     asection *sec,
	     void *xxx ATTRIBUTE_UNUSED) {
    segment_info_type *seginfo = seg_info (sec);

    fixup_segment (seginfo->fix_root, sec);
}

/**
 * @Description: 正式写入文件时设置符号表
 */
static void
set_symtab (void) {
    int nsyms;
    asymbol **asympp;
    symbolS *symp;
    bool result;
    nsyms = 0;
    for (symp = symbol_rootP; symp; symp = symbol_next (symp))
        if (!symbol_removed_p (symp)
            && (bfd_keep_unused_section_symbols (stdoutput)
            || !symbol_section_p (symp)
            || symbol_used_in_reloc_p (symp)))
        nsyms++;
    if (nsyms) {
        int i;
        bfd_size_type amt = (bfd_size_type) nsyms * sizeof (asymbol *);

        asympp = (asymbol **) bfd_alloc (stdoutput, amt);
        symp = symbol_rootP;
        for (i = 0; i < nsyms; symp = symbol_next (symp))
            if (!symbol_removed_p (symp)
                && (bfd_keep_unused_section_symbols (stdoutput)
                || !symbol_section_p (symp)
                || symbol_used_in_reloc_p (symp))) {
                asympp[i] = symbol_get_bfdsym (symp);
                if (asympp[i]->flags != BSF_SECTION_SYM
                    || !(bfd_is_const_section (asympp[i]->section)
                    && asympp[i]->section->symbol == asympp[i]))
                    asympp[i]->flags |= BSF_KEEP;
                    symbol_mark_written (symp);
                    /* Include this section symbol in the symbol table.  */
                    if (symbol_section_p (symp))
                    asympp[i]->flags |= BSF_SECTION_SYM_USED;
                    i++;
            }
    } else 
        asympp = 0;
    result = bfd_set_symtab (stdoutput, asympp, nsyms);
    gas_assert (result);
    symbol_table_frozen = 1;
}

static void
md_generate_nops (fragS *f ATTRIBUTE_UNUSED,
		  char *where ATTRIBUTE_UNUSED,
		  offsetT count ATTRIBUTE_UNUSED,
		  int control ATTRIBUTE_UNUSED)
{
  as_bad (_("unimplemented .nops directive"));
}
static void
write_contents (bfd *abfd ATTRIBUTE_UNUSED,
		asection *sec,
		void *xxx ATTRIBUTE_UNUSED) {
    segment_info_type *seginfo = seg_info (sec);
    addressT offset = 0;
    fragS *f;

    /* Write out the frags.  */
    if (seginfo == NULL
        || !(bfd_section_flags (sec) & SEC_HAS_CONTENTS))
        return;

    for (f = seginfo->frchainP->frch_root;
        f;
        f = f->fr_next) {
        int x;
        addressT fill_size;
        char *fill_literal;
        offsetT count;

        gas_assert (f->fr_type == rs_fill || f->fr_type == rs_fill_nop);
        if (f->fr_fix) {
            x = bfd_set_section_contents (stdoutput, sec,
                            f->fr_literal, (file_ptr) offset,
                            (bfd_size_type) f->fr_fix);
            if (!x)
                as_fatal (ngettext ("can't write %ld byte "
                        "to section %s of %s: '%s'",
                        "can't write %ld bytes "
                        "to section %s of %s: '%s'",
                        (long) f->fr_fix),
                    (long) f->fr_fix,
                    bfd_section_name (sec), bfd_get_filename (stdoutput),
                    bfd_errmsg (bfd_get_error ()));
            offset += f->fr_fix;
        }

        fill_size = f->fr_var;
        count = f->fr_offset;
        fill_literal = f->fr_literal + f->fr_fix;

        if (f->fr_type == rs_fill_nop) {
            gas_assert (count >= 0 && fill_size == 1);
            if (count > 0) {
                char *buf = xmalloc (count);
                md_generate_nops (f, buf, count, *fill_literal);
                x = bfd_set_section_contents
                    (stdoutput, sec, buf, (file_ptr) offset,
                    (bfd_size_type) count);
                if (!x)
                    as_fatal (ngettext ("can't fill %ld byte "
                                "in section %s of %s: '%s'",
                                "can't fill %ld bytes "
                                "in section %s of %s: '%s'",
                                (long) count),
                        (long) count,
                        bfd_section_name (sec),
                        bfd_get_filename (stdoutput),
                        bfd_errmsg (bfd_get_error ()));
                offset += count;
                free (buf);
            }
            continue;
        }

        gas_assert (count >= 0);
        if (fill_size && count) {
            char buf[256];
            if (fill_size > sizeof (buf)) {
                /* Do it the old way. Can this ever happen?  */
                while (count--) {
                    x = bfd_set_section_contents (stdoutput, sec,
                                    fill_literal,
                                    (file_ptr) offset,
                                    (bfd_size_type) fill_size);
                    if (!x)
                        as_fatal (ngettext ("can't fill %ld byte "
                                "in section %s of %s: '%s'",
                                "can't fill %ld bytes "
                                "in section %s of %s: '%s'",
                                (long) fill_size),
                            (long) fill_size,
                            bfd_section_name (sec),
                            bfd_get_filename (stdoutput),
                            bfd_errmsg (bfd_get_error ()));
                    offset += fill_size;
                }
            } else {
                /* Build a buffer full of fill objects and output it as
                often as necessary. This saves on the overhead of
                potentially lots of bfd_set_section_contents calls.  */
                int n_per_buf, i;
                if (fill_size == 1) {
                    n_per_buf = sizeof (buf);
                    memset (buf, *fill_literal, n_per_buf);
                } else {
                    char *bufp;
                    n_per_buf = sizeof (buf) / fill_size;
                    for (i = n_per_buf, bufp = buf; i; i--, bufp += fill_size)
                        memcpy (bufp, fill_literal, fill_size);
                }
                for (; count > 0; count -= n_per_buf) {
                    n_per_buf = n_per_buf > count ? count : n_per_buf;
                    x = bfd_set_section_contents
                        (stdoutput, sec, buf, (file_ptr) offset,
                        (bfd_size_type) n_per_buf * fill_size);
                    if (!x)
                        as_fatal (ngettext ("can't fill %ld byte "
                                "in section %s of %s: '%s'",
                                "can't fill %ld bytes "
                                "in section %s of %s: '%s'",
                                (long) (n_per_buf * fill_size)),
                            (long) (n_per_buf * fill_size),
                            bfd_section_name (sec),
                            bfd_get_filename (stdoutput),
                            bfd_errmsg (bfd_get_error ()));
                    offset += n_per_buf * fill_size;
                }
            }
        }
    }
}

// 注册重定位
static void
install_reloc (asection *sec, arelent *reloc, fragS *fragp,
	       const char *file, unsigned int line) {
    char *err;
    bfd_reloc_status_type s;
    asymbol *sym;

    if (reloc->sym_ptr_ptr != NULL
        && (sym = *reloc->sym_ptr_ptr) != NULL
        && (sym->flags & BSF_KEEP) == 0
        && ((sym->flags & BSF_SECTION_SYM) == 0
        || (EMIT_SECTION_SYMBOLS
            && !bfd_is_abs_section (sym->section))))
        as_bad_where (file, line, _("redefined symbol cannot be used on reloc"));
    
    s = bfd_install_relocation (stdoutput, reloc,
			      fragp->fr_literal, fragp->fr_address,
			      sec, &err);
    switch (s) {
        case bfd_reloc_ok:
            break;
        case bfd_reloc_overflow:
            as_bad_where (file, line, _("relocation overflow"));
            break;
        case bfd_reloc_outofrange:
            as_bad_where (file, line, _("relocation out of range"));
            break;
        default:
            as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
                file, line, s);
    }
}

/**
 * @Description: 书写重定位
 */
static void
write_relocs (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
	      void *xxx ATTRIBUTE_UNUSED) {
    segment_info_type *seginfo = seg_info (sec);
    unsigned int n;
    struct reloc_list *my_reloc_list, **rp, *r;
    arelent **relocs;
    fixS *fixp;
    fragS *last_frag;

    /* If seginfo is NULL, we did not create this section; don't do
        anything with it.  */
    if (seginfo == NULL)
        return;

    n = 0;
    for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
        if (!fixp->fx_done)
        n++;


    /* Extract relocs for this section from reloc_list.  */
    rp = &reloc_list;

    my_reloc_list = NULL;
    while ((r = *rp) != NULL) {
        if (r->u.b.sec == sec) {
            *rp = r->next;
            r->next = my_reloc_list;
            my_reloc_list = r;
            n++;
        } else
            rp = &r->next;
    }

    relocs = XCNEWVEC (arelent *, n);

    n = 0;
    r = my_reloc_list;
    last_frag = NULL;
    for (fixp = seginfo->fix_root; fixp != (fixS *) NULL; fixp = fixp->fx_next) {
        int fx_size, slack;
        valueT loc;
        arelent **reloc;
#ifndef RELOC_EXPANSION_POSSIBLE
        arelent *rel;

        reloc = &rel;
#endif

        if (fixp->fx_done)
            continue;

        fx_size = fixp->fx_size;
        slack = TC_FX_SIZE_SLACK (fixp);
        if (slack > 0)
            fx_size = fx_size > slack ? fx_size - slack : 0;
        loc = fixp->fx_where + fx_size;
        if (slack >= 0 && loc > fixp->fx_frag->fr_fix)
            as_bad_where (fixp->fx_file, fixp->fx_line,
                _("internal error: fixup not contained within frag"));

#ifdef obj_fixup_removed_symbol
        if (fixp->fx_addsy && symbol_removed_p (fixp->fx_addsy))
            obj_fixup_removed_symbol (&fixp->fx_addsy);
        if (fixp->fx_subsy && symbol_removed_p (fixp->fx_subsy))
            obj_fixup_removed_symbol (&fixp->fx_subsy);
#endif

        *reloc = tc_gen_reloc (sec, fixp);


        while (*reloc) {
            relocs[n++] = *reloc;
            install_reloc (sec, *reloc, fixp->fx_frag,
                fixp->fx_file, fixp->fx_line);
#ifndef RELOC_EXPANSION_POSSIBLE
            break;
#else
            reloc++;
#endif
        }
    }

    bfd_set_reloc (stdoutput, sec, n ? relocs : NULL, n);
}
void
test (bfd *abfd,
		       void (*operation) (bfd *, asection *, void *),
		       void *user_storage)
{
  asection *sect;
  unsigned int i = 0;

  for (sect = abfd->sections; sect != NULL; i++, sect = sect->next) {
    (*operation) (abfd, sect, user_storage);
    break;
  }
}

static void
test1 (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
	      void *xxx ATTRIBUTE_UNUSED) {
    segment_info_type *seginfo = seg_info (sec);
    unsigned int n;
    struct reloc_list *my_reloc_list, **rp, *r;
    arelent **relocs;
    fixS *fixp;
    fragS *last_frag;
    int n1 = 0;
    int n2 = 0;
    for (fixp = seginfo->fix_root; fixp != (fixS *) NULL; fixp = fixp->fx_next) {
        int fx_size, slack;
        valueT loc;
        arelent **reloc;
#ifndef RELOC_EXPANSION_POSSIBLE
        arelent *rel;

        reloc = &rel;
#endif
        n2++;
        if (fixp->fx_done)
            continue;
        n1 = n2;
    }
    printf("test1:%d,%d\n",n1,n2);
}

void
write_object_file (void) {
    struct relax_seg_info rsi;
    // 将每个子段对齐
    subsegs_finish ();
    // 从现在开始，我们不再关心子段。对于每个段建立一个碎片链
    // 通过fr_next链接
    {
        int i;

        bfd_section_list_remove (stdoutput, reg_section);
        bfd_section_list_remove (stdoutput, expr_section);
        stdoutput->section_count -= 2;
        i = 0;
        bfd_map_over_sections (stdoutput, renumber_sections, &i);       
    }

    bfd_map_over_sections (stdoutput, chain_frchains_together, (char *) 0);
    if (flag_readonly_data_in_text) {
        merge_data_into_text ();
    }
    
    rsi.pass = 0;
    while (1) {
        rsi.changed = 0;
        bfd_map_over_sections (stdoutput, relax_seg, &rsi);
        rsi.pass++;
        if (!rsi.changed)
            break;
    }
    finalize_syms = TC_FINALIZE_SYMS_BEFORE_SIZE_SEG;

    bfd_map_over_sections (stdoutput, size_seg, (char *) 0);
    /* Relaxation has completed.  Freeze all syms.  */
    finalize_syms = 1;
#ifdef md_post_relax_hook
    md_post_relax_hook;
#endif
    // 解析symbol values
    if (symbol_rootP) {
        symbolS *symp;

        for (symp = symbol_rootP; symp; symp = symbol_next (symp))
            resolve_symbol_value (symp);
    }
    resolve_local_symbol_values ();

    resolve_reloc_expr_symbols ();
#ifdef obj_frob_file_before_adjust
    obj_frob_file_before_adjust ();
#endif
    // error :这行代码的作用是对输出文件中的每个section都调用一次adjust_reloc_syms函数。
    bfd_map_over_sections (stdoutput, adjust_reloc_syms, (char *) 0);

    bfd_map_over_sections (stdoutput, fix_segment, (char *) 0);
    if (symbol_rootP) {
        symbolS *symp;
        bool skip_next_symbol = false;

        for (symp = symbol_rootP; symp; symp = symbol_next (symp)) {
            int punt = 0;
            const char *name;
            if (skip_next_symbol) {
                symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);
                skip_next_symbol = false;
                continue;
            }
            if (symbol_mri_common_p (symp)) {
                if (S_IS_EXTERNAL (symp))
                    as_bad (_("%s: global symbols not supported in common sections"),
                S_GET_NAME (symp));
                symbol_remove (symp, &symbol_rootP, &symbol_lastP);
                continue;
            }
            name = S_GET_NAME (symp);
            if (name) {
                const char *name2 =
                    decode_local_label_name ((char *) S_GET_NAME (symp));
                /* They only differ if `name' is a fb or dollar local
                label name.  */
                if (name2 != name && ! S_IS_DEFINED (symp))
                    as_bad (_("local label `%s' is not defined"), name2);
            }
            // 可能引入了更多的符号，所以需要解析
            resolve_symbol_value (symp);
            // 跳过等于undefined或common的符号
            if (symbol_equated_reloc_p (symp)
                || S_IS_WEAKREFR (symp)) {
                const char *sname = S_GET_NAME (symp);

                if (S_IS_COMMON (symp)
                && !TC_FAKE_LABEL (sname)
                && !S_IS_WEAKREFR (symp)) {
                expressionS *e = symbol_get_value_expression (symp);

                as_bad (_("`%s' can't be equated to common symbol `%s'"),
                    sname, S_GET_NAME (e->X_add_symbol));
                }
                if (S_GET_SEGMENT (symp) == reg_section) {
                    /* Report error only if we know the symbol name.  */
                    if (S_GET_NAME (symp) != reg_section->name)
                        as_bad (_("can't make global register symbol `%s'"),
                            sname);
                }
                symbol_remove (symp, &symbol_rootP, &symbol_lastP);
                continue;
            }
#ifdef obj_frob_symbol
            obj_frob_symbol (symp, punt);
#endif  
            if (symp == abs_section_sym
                || (! EMIT_SECTION_SYMBOLS
                && symbol_section_p (symp))
                || (!S_IS_EXTERNAL (symp)
                && (punt || S_IS_LOCAL (symp) ||
                    (S_IS_WEAKREFD (symp) && ! symbol_used_p (symp)))
                && ! symbol_used_in_reloc_p (symp))) {
                    symbol_remove (symp, &symbol_rootP, &symbol_lastP);

                    continue;
            }   
            /* Make sure we really got a value for the symbol.  */
            if (! symbol_resolved_p (symp)) {
                as_bad (_("can't resolve value for symbol `%s'"),
                S_GET_NAME (symp));
                symbol_mark_resolved (symp);
            }
            symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);
            if (symbol_get_bfdsym (symp)->flags & BSF_WARNING)
                skip_next_symbol = true;
        }       
    }

#ifdef obj_adjust_symtab
    obj_adjust_symtab ();
#endif   
    /* Stop if there is an error.  */
    if (!flag_always_generate_output && had_errors ())
        return;
    // 写入文件
    set_symtab ();
#ifdef obj_frob_file
    obj_frob_file ();
#endif
    bfd_map_over_sections (stdoutput, write_relocs, (char *) 0);
#ifdef obj_frob_file_after_relocs
    obj_frob_file_after_relocs ();
#endif
#if defined OBJ_ELF || defined OBJ_MAYBE_ELF
    if (IS_ELF && flag_use_elf_stt_common)
        stdoutput->flags |= BFD_CONVERT_ELF_COMMON | BFD_USE_ELF_STT_COMMON;
#endif

    // 写入文件
    bfd_map_over_sections (stdoutput, write_contents, (char *) 0);
    printf("write to the main.o over\n");
}